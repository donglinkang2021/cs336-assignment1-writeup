\documentclass{article}
\usepackage[authoryear, round]{natbib} % Citation format
\usepackage{hyperref}   % Hyperlink support
\usepackage{tcolorbox}
\usepackage{amsmath}    % Math formula support
\usepackage{amssymb}    % Math symbol support
\usepackage{amsfonts}   % Math font support
\usepackage{amsthm}     % Theorem environment support
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{proposition}{Proposition}
\usepackage{algorithm, algorithmicx, algpseudocode} % Algorithm support
\usepackage{lmodern}
\usepackage{graphicx}   % Image support
\usepackage{listings}   % Code highlighting support
\usepackage{geometry}   % Page setup
\geometry{a4paper, margin=1in} % Set page size and margins
\usepackage{tikz} % TikZ drawing support
\usetikzlibrary{mindmap, shadings}
\usepackage{enumitem} % Enhanced list environments

\usepackage{xcolor}    % Color support
\definecolor{lightgray}{gray}{0.90} % Light gray
\definecolor{commentgreen}{rgb}{0.161, 0.510, 0.322} % Define custom green
\definecolor{answercolor}{rgb}{0.0, 0.0, 0.8} % Blue for answers

\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{commentgreen},
    morecomment=[l][\color{magenta}]{\#},
    showstringspaces=false,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{lightgray!10},
    escapeinside={(*@}{@*)}, % allow LaTeX commands in code, e.g., (*@\textbf{bold}@*)
    literate={'}{\textquotesingle}1 % handle single quotes correctly
}

\lstset{style=pythonstyle} % Set the default style for listings

% Define answer environment
\newtcolorbox{answer}{
    colback=blue!5!white,
    colframe=blue!75!black,
    title=Answer,
    fonttitle=\bfseries,
    left=2mm,
    right=2mm,
    boxsep=1mm
}

% Define problem counter and environment
\newcounter{problem}
\newcommand{\problem}[2]{
    \stepcounter{problem}
    \subsection{Problem (\texttt{#1}): #2}
    \vspace{-2em} % Reduce space after subsection
    \noindent
}

% Remove paragraph indentation and add spacing
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt}

\title{CS336 Assignment 1 Writeup}
\author{Linkang Dong}
\date{\today}

\begin{document}

\maketitle

% Add table of contents
\tableofcontents

\section{Assignment Overview}
\vspace{-1em}

This document contains my solutions to CS336 Assignment 1. Each problem is answered in detail with supporting explanations, calculations, and code where applicable.

\section{Byte-Pair Encoding (BPE) Tokenizer}
\vspace{-1em}

\problem{unicode1}{Understanding Unicode (1 point)}

\begin{enumerate}[label=(\alph*)]
    \item {What Unicode character does \texttt{chr(0)} return?}
    
    {\textbf{Deliverable}: A one-sentence response.}
    
    \begin{answer}
    \texttt{chr(0)} returns the null byte \texttt{'\textbackslash x00'}.
    \end{answer}
    
    \item {How does this character's string representation (\texttt{\_\_repr\_\_()} differ from its printed representation?}
    
    {\textbf{Deliverable}: A one-sentence response.}
    
    \begin{answer}
    \texttt{chr(0).\_\_repr\_\_()} returns \texttt{'\textbackslash\textbackslash x00'}, adding a backslash \texttt{\textbackslash} before the \texttt{x}.
    \end{answer}
    
    \item {What happens when this character occurs in text? It may be helpful to play around with the following in your Python interpreter and see if it matches your expectations:}
    
    \begin{lstlisting}
>>> chr(0)
>>> print(chr(0))
>>> "this is a test" + chr(0) + "string"
>>> print("this is a test" + chr(0) + "string")
    \end{lstlisting}
    
    {\textbf{Deliverable}: A one-sentence response.}
    
    \begin{answer}
    It prints nothing when it occurs in text; the result is "this is a teststring".
    \end{answer}
\end{enumerate}

\problem{unicode2}{Unicode Encodings (3 points)}

\begin{enumerate}[label=(\alph*)]
    \item {What are some reasons to prefer training our tokenizer on UTF-8 encoded bytes, rather than UTF-16 or UTF-32? It may be helpful to compare the output of these encodings for various input strings.}
    
    {\textbf{Deliverable}: A one-to-two sentence response.}
    
    \begin{answer}
    UTF-8 is more space-efficient for texts that are primarily in ASCII, as it uses one byte for these characters, while UTF-16 and UTF-32 use two and four bytes respectively; additionally, UTF-8 is backward compatible with ASCII and is the most widely used encoding on the web (more than 98\% of all webpages).
    \end{answer}
    
    \item {Consider the following (incorrect) function, which is intended to decode a UTF-8 byte string into a Unicode string. Why is this function incorrect? Provide an example of an input byte string that yields incorrect results.}
    
    \begin{lstlisting}
def decode_utf8_bytes_to_str_wrong(bytestring: bytes):
    return "".join([bytes([b]).decode("utf-8") for b in bytestring])
    \end{lstlisting}
    
    \begin{lstlisting}
>>> decode_utf8_bytes_to_str_wrong("hello".encode("utf-8"))
'hello'
    \end{lstlisting}
    
    {\textbf{Deliverable}: An example input byte string for which \texttt{decode\_utf8\_bytes\_to\_str\_wrong} produces incorrect output, with a one-sentence explanation of why the function is incorrect.}
    
    \begin{answer}
    An example input byte string is \texttt{b'\textbackslash xc3\textbackslash xa9'}, which represents the character 'é' in UTF-8. The function is incorrect because \textbf{it decodes each byte individually}, leading to a \texttt{UnicodeDecodeError} since \texttt{b'\textbackslash xc3'} and \texttt{b'\textbackslash xa9'} are not valid standalone UTF-8 characters.
    
    \begin{lstlisting}
>>> "hello".encode("utf-8")
b'hello'
>>> "hello".encode("utf-8").decode("utf-8")
'hello'
>>> decode_utf8_bytes_to_str_wrong("hello".encode("utf-8"))
'hello'
>>> "é".encode("utf-8")
b'\xc3\xa9'
>>> "é".encode("utf-8").decode("utf-8")
'é' 
>>> decode_utf8_bytes_to_str_wrong("é".encode("utf-8"))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in decode_utf8_bytes_to_str_wrong
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc3 in position 0: unexpected end of data
    \end{lstlisting}
    \end{answer}
    
    \item {Give a two byte sequence that does not decode to any Unicode character(s).}
    
    {\textbf{Deliverable}: An example, with a one-sentence explanation.}
    
    \begin{answer}
    \begin{lstlisting}
>>> b'\x80\x80'.decode("utf-8") 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0: invalid start byte
    \end{lstlisting}

    The byte sequence \texttt{b'\textbackslash x80\textbackslash x80'} does not decode to any Unicode characters because it is an invalid UTF-8 sequence; in UTF-8, continuation bytes (bytes starting with \texttt{10xxxxxx}) must follow a valid leading byte, and \texttt{0x80} cannot be a leading byte.
    \end{answer}
\end{enumerate}

\end{document}