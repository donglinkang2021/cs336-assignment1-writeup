\section{Transformer Language Model Architecture}

All transformer model implementations in this section are available at: \url{https://github.com/donglinkang2021/assignment1-basics/blob/main/cs336_basics/model.py}

The complete implementation passes all 13 tests with the following results:
\begin{lstlisting}
(cs336-basics) [root:assignment1-basics]$ uv run pytest tests/test_model.py
======================= test session starts ========================
platform linux -- Python 3.13.7, pytest-8.4.1, pluggy-1.6.0
rootdir: standford-cs336/assignment1-basics
configfile: pyproject.toml
plugins: jaxtyping-0.3.2, hydra-core-1.3.2
collected 13 items                                                 

tests/test_model.py::test_linear PASSED
tests/test_model.py::test_embedding PASSED
tests/test_model.py::test_swiglu PASSED
tests/test_model.py::test_scaled_dot_product_attention PASSED
tests/test_model.py::test_4d_scaled_dot_product_attention PASSED
tests/test_model.py::test_multihead_self_attention PASSED
tests/test_model.py::test_multihead_self_attention_with_rope PASSED
tests/test_model.py::test_transformer_lm PASSED
tests/test_model.py::test_transformer_lm_truncated_input PASSED
tests/test_model.py::test_transformer_block PASSED
tests/test_model.py::test_rmsnorm PASSED
tests/test_model.py::test_rope PASSED
tests/test_model.py::test_silu_matches_pytorch PASSED

======================== 13 passed in 2.63s ========================
\end{lstlisting}

\problem{linear}{Implementing the linear module (1 point)}

\textbf{Deliverable}: Implement a Linear class that inherits from \lstinline{torch.nn.Module} and performs a linear transformation. Your implementation should follow the interface of PyTorch's built-in \lstinline{nn.Linear} module, except for not having a bias argument or parameter. We recommend the following interface:

\begin{itemize}
    \item \lstinline{def __init__(self, in_features, out_features, device=None, dtype=None)} - Construct a linear transformation module. This function should accept the following parameters:
    \begin{itemize}
        \item \lstinline{in_features: int} - final dimension of the input
        \item \lstinline{out_features: int} - final dimension of the output
        \item \lstinline{device: torch.device | None = None} - Device to store the parameters on
        \item \lstinline{dtype: torch.dtype | None = None} - Datatype of the parameters
    \end{itemize}
    
    \item \lstinline{def forward(self, x: torch.Tensor) -> torch.Tensor} - Apply the linear transformation to the input.
\end{itemize}

Make sure to:
\begin{itemize}
    \item subclass \lstinline{nn.Module}
    \item call the superclass constructor
    \item construct and store your parameter as $W$ (not $W^\top$) for memory ordering reasons, putting it in an \lstinline{nn.Parameter}
    \item of course, don't use \lstinline{nn.Linear} or \lstinline{nn.functional.linear}
\end{itemize}

For initializations, use the settings from above along with \lstinline{torch.nn.init.trunc_normal_} to initialize the weights.

To test your Linear module, implement the test adapter at \texttt{[adapters.run\_linear]}. The adapter should load the given weights into your Linear module. You can use \lstinline{Module.load_state_dict} for this purpose. Then, run \texttt{uv run pytest -k test\_linear}.

\begin{answer}
\textbf{Note}: Although the problem specification mentions not having a bias parameter, the implementation includes a bias parameter to ensure compatibility with the provided tests that load pre-trained weights with bias terms. However, in our final transformer architecture, we set \lstinline{bias=False} to follow the no-bias design.
\end{answer}

\begin{lstlisting}
# uv run pytest -k test_linear
class Linear(nn.Module):
    """ A simple linear layer implemented from scratch."""
    in_features: int
    out_features: int
    weight: torch.Tensor
    
    def __init__(
        self, 
        in_features:int, 
        out_features:int, 
        bias:bool=False,
        device=None, 
        dtype=None, 
    ) -> None:
        kwargs = {'device': device, 'dtype': dtype}
        super().__init__()
        self.in_features = in_features
        self.out_features = out_features
        self.weight = nn.Parameter(
            torch.empty((out_features, in_features), **kwargs)
        )
        if bias:
            self.bias = nn.Parameter(torch.empty(out_features, **kwargs))
        else:
            self.register_parameter('bias', None)
    
    def forward(self, x:torch.Tensor) -> torch.Tensor:
        # [..., in_features] -> [..., out_features]
        return torch.einsum('...i,oi->...o', x, self.weight) + (
            self.bias if self.bias is not None else 0
        )
\end{lstlisting}

\problem{embedding}{Implement the embedding module (1 point)}

\textbf{Deliverable}: Implement the Embedding class that inherits from \lstinline{torch.nn.Module} and performs an embedding lookup. Your implementation should follow the interface of PyTorch's built-in \lstinline{nn.Embedding} module. We recommend the following interface:

\begin{itemize}
    \item \lstinline{def __init__(self, num_embeddings, embedding_dim, device=None, dtype=None)} - Construct an embedding module. This function should accept the following parameters:
    \begin{itemize}
        \item \lstinline{num_embeddings: int} - Size of the vocabulary
        \item \lstinline{embedding_dim: int} - Dimension of the embedding vectors, i.e., $d_{\text{model}}$
        \item \lstinline{device: torch.device | None = None} - Device to store the parameters on
        \item \lstinline{dtype: torch.dtype | None = None} - Data type of the parameters
    \end{itemize}
    
    \item \lstinline{def forward(self, token_ids: torch.Tensor) -> torch.Tensor} - Lookup the embedding vectors for the given token IDs.
\end{itemize}

Make sure to:
\begin{itemize}
    \item subclass \lstinline{nn.Module}
    \item call the superclass constructor
    \item initialize your embedding matrix as a \lstinline{nn.Parameter}
    \item store the embedding matrix with the $d_{\text{model}}$ being the final dimension
    \item of course, don't use \lstinline{nn.Embedding} or \lstinline{nn.functional.embedding}
\end{itemize}

Again, use the settings from above for initialization, and use \lstinline{torch.nn.init.trunc_normal_} to initialize the weights.

To test your implementation, implement the test adapter at \texttt{[adapters.run\_embedding]}. Then, run \texttt{uv run pytest -k test\_embedding}.

\begin{lstlisting}
# uv run pytest -k test_embedding
class Embedding(nn.Module):
    """ A simple embedding layer implemented from scratch. """
    num_embeddings: int
    embedding_dim: int
    weight: torch.Tensor
    
    def __init__(
        self, 
        num_embeddings:int, 
        embedding_dim:int, 
        device=None, 
        dtype=None
    ) -> None:
        kwargs = {'device': device, 'dtype': dtype}
        super().__init__()
        self.num_embeddings = num_embeddings
        self.embedding_dim = embedding_dim
        self.weight = nn.Parameter(
            torch.empty((num_embeddings, embedding_dim), **kwargs)
        )
    
    def forward(self, token_ids:torch.Tensor) -> torch.Tensor:
        # [...] -> [..., embedding_dim]
        return self.weight[token_ids]
\end{lstlisting}

\problem{rmsnorm}{Root Mean Square Layer Normalization (1 point)}

\textbf{Deliverable}: Implement RMSNorm as a \lstinline{torch.nn.Module}. We recommend the following interface:

\begin{itemize}
    \item \lstinline{def __init__(self, d_model: int, eps: float = 1e-5, device=None, dtype=None)} - Construct the RMSNorm module. This function should accept the following parameters:
    \begin{itemize}
        \item \lstinline{d_model: int} - Hidden dimension of the model
        \item \lstinline{eps: float = 1e-5} - Epsilon value for numerical stability
        \item \lstinline{device: torch.device | None = None} - Device to store the parameters on
        \item \lstinline{dtype: torch.dtype | None = None} - Data type of the parameters
    \end{itemize}
    
    \item \lstinline{def forward(self, x: torch.Tensor) -> torch.Tensor} - Process an input tensor of shape \lstinline{(batch_size, sequence_length, d_model)} and return a tensor of the same shape.
\end{itemize}

\textbf{Note}: Remember to upcast your input to \lstinline{torch.float32} before performing the normalization (and later downcast to the original dtype), as described above.

To test your implementation, implement the test adapter at \texttt{[adapters.run\_rmsnorm]}. Then, run \texttt{uv run pytest -k test\_rmsnorm}.

\begin{lstlisting}
# uv run pytest -k test_rmsnorm
class RMSNorm(nn.Module):
    """
    Root Mean Square Layer Normalization (RMSNorm)
    Reference https://github.com/donglinkang2021/normalize-layers-pytorch/
    """
    d_model: int
    eps: float
    weight: torch.Tensor
    
    def __init__(
        self, 
        d_model: int, 
        eps: float = 1e-5, 
        device=None, 
        dtype=None
    ) -> None:
        kwargs = {'device': device, 'dtype': dtype}
        super().__init__()
        self.weight = nn.Parameter(torch.empty(d_model, **kwargs))
        self.eps = eps

    def forward(self, x:torch.Tensor) -> torch.Tensor:
        # [..., d_model] -> [..., d_model]
        in_dtype = x.dtype
        x = x.to(torch.float32)
        var = x.pow(2).mean(dim=-1, keepdim=True) + self.eps
        x_out = x * var.rsqrt() * self.weight
        return x_out.to(in_dtype)
\end{lstlisting}

\problem{positionwise\_feedforward}{Implement the position-wise feed-forward network (2 points)}

\textbf{Deliverable}: Implement the SwiGLU feed-forward network, composed of a SiLU activation function and a GLU.

\textbf{Note}: In this particular case, you should feel free to use \lstinline{torch.sigmoid} in your implementation for numerical stability.

You should set $d_{\text{ff}}$ to approximately $\frac{8}{3} \times d_{\text{model}}$ in your implementation, while ensuring that the dimensionality of the inner feed-forward layer is a multiple of 64 to make good use of your hardware.

To test your implementation against our provided tests, you will need to implement the test adapter at \texttt{[adapters.run\_swiglu]}. Then, run \texttt{uv run pytest -k test\_swiglu} to test your implementation.

\begin{lstlisting}
# uv run pytest -k test_silu
def silu(x:torch.Tensor) -> torch.Tensor:
    return x * torch.sigmoid(x)

# uv run pytest -k test_swiglu
class SwiGLU(nn.Module):
    """ SwiGLU FFN """
    d_model: int
    d_ff: int
    
    def __init__(self, d_model:int, d_ff:int) -> None:
        super().__init__()
        self.d_model = d_model
        # should be roughly d_ff = 8/3 * d_model, 
        # then the parameter count = 3 * d_model * 8/3 * d_model = 8 * d_model^2
        self.d_ff = d_ff
        self.w1 = Linear(in_features=d_model, out_features=d_ff)
        self.w2 = Linear(in_features=d_ff, out_features=d_model)
        self.w3 = Linear(in_features=d_model, out_features=d_ff)
    
    def forward(self, x:torch.Tensor) -> torch.Tensor:
        # [..., d_model] -> [..., d_model]
        return self.w2(silu(self.w1(x)) * self.w3(x))
\end{lstlisting}

Here we also provide an alternative SiLU-based FFN for ablation studies later. You can ignore this part for now.

\begin{lstlisting}
class SiLUFFN(nn.Module):
    """ FFN with SiLU activation """
    d_model: int
    d_ff: int

    def __init__(self, d_model:int, d_ff:int) -> None:
        super().__init__()
        self.d_model = d_model
        # should be d_ff = 4 * d_model, 
        # then the parameter count = 2 * d_model * 4 * d_model = 8 * d_model^2
        self.d_ff = d_ff
        self.w1 = Linear(in_features=d_model, out_features=d_ff)
        self.w2 = Linear(in_features=d_ff, out_features=d_model)

    def forward(self, x:torch.Tensor) -> torch.Tensor:
        # [..., d_model] -> [..., d_model]
        return self.w2(silu(self.w1(x)))
\end{lstlisting}

\problem{rope}{Implement RoPE (2 points)}

\textbf{Deliverable}: Implement a class RotaryPositionalEmbedding that applies RoPE to the input tensor. The following interface is recommended:

\begin{itemize}
    \item \lstinline{def __init__(self, theta: float, d_k: int, max_seq_len: int, device=None)} - Construct the RoPE module and create buffers if needed.
    \begin{itemize}
        \item \lstinline{theta: float} - $\Theta$ value for the RoPE
        \item \lstinline{d_k: int} - dimension of query and key vectors
        \item \lstinline{max_seq_len: int} - Maximum sequence length that will be inputted
        \item \lstinline{device: torch.device | None = None} - Device to store the buffer on
    \end{itemize}
    
    \item \lstinline{def forward(self, x: torch.Tensor, token_positions: torch.Tensor) -> torch.Tensor} - Process an input tensor of shape \lstinline{(..., seq_len, d_k)} and return a tensor of the same shape. 
    
    Note that you should tolerate $x$ with an arbitrary number of batch dimensions. You should assume that the token positions are a tensor of shape \lstinline{(..., seq_len)} specifying the token positions of $x$ along the sequence dimension.

    You should use the token positions to slice your (possibly precomputed) cos and sin tensors along the sequence dimension.
\end{itemize}

To test your implementation, complete \texttt{[adapters.run\_rope]} and make sure it passes \texttt{uv run pytest -k test\_rope}.

\begin{answer}
Implementation references: \href{https://github.com/karpathy/nano-llama31/blob/master/llama31.py}{[karpathy/nano-llama31]} and \href{https://github.com/GeeeekExplorer/nano-vllm/blob/main/nanovllm/layers/rotary_embedding.py}{[GeeeekExplorer/nano-vllm]}.

\textbf{Important}: When implementing RoPE, pay special attention to the tensor splitting of $x$. The dimension splitting is performed on the \lstinline{model_dim} (i.e., $d_k$), where we split the last dimension into pairs and apply rotation to each pair separately using the precomputed cos/sin values. 
\end{answer}

\begin{lstlisting}
# uv run pytest -k test_rope
class RotaryPositionalEmbedding(nn.Module):
    """ Rotary Positional Embedding (RoPE) """
    theta: float
    d_k: int
    max_seq_len: int
    
    def __init__(self, theta: float, d_k: int, max_seq_len: int, device=None):
        super().__init__()
        self.theta = theta
        self.d_k = d_k
        self.max_seq_len = max_seq_len
        self.register_buffer(
            'cos_sin', 
            precompute_freqs_cis(d_k, max_seq_len, theta),
            persistent=False
        )
    
    def forward(self, x: torch.Tensor, token_positions: torch.Tensor) -> torch.Tensor:
        # [..., seq_len, dim], [seq_len,] -> [..., seq_len, dim]
        cos_sin = self.cos_sin[:x.size(-2)] if token_positions is None else self.cos_sin[token_positions]
        return apply_rotary_emb(x, cos_sin)


def precompute_freqs_cis(head_dim: int, max_len: int, theta: float = 10000.0) -> torch.Tensor:
    # shape (head_dim/2,)
    freqs = 1.0 / (theta ** (torch.arange(0, head_dim, 2).float() / head_dim)) 
    
    # shape (max_len,)
    t = torch.arange(max_len, device=freqs.device).float() 
    
    # equal to einsum('i,j->ij', t, freqs), shape (max_len, head_dim/2)
    freqs = torch.outer(t, freqs) 
    
    # complex64, equal to torch.complex(torch.cos(freqs), torch.sin(freqs))
    freqs_cis = torch.polar(torch.ones_like(freqs), freqs)  
    
    # [cos, sin] shape (max_len, head_dim/2 * 2)
    cos_sin = torch.cat([freqs_cis.real, freqs_cis.imag], dim=-1) 
    return cos_sin
    
def apply_rotary_emb(x:torch.Tensor, cos_sin:torch.Tensor):
    # x1, x2 = torch.chunk(x, 2, dim=-1) # wrong
    x1, x2 = x.reshape(*x.shape[:-1], -1, 2).unbind(-1)
    cos, sin = torch.chunk(cos_sin, 2, dim=-1)
    x_out = torch.stack([x1 * cos - x2 * sin, 
                         x1 * sin + x2 * cos], dim=-1)
    return x_out.reshape(*x.shape).type_as(x)
\end{lstlisting}

\problem{softmax}{Implement softmax (1 point)}

\textbf{Deliverable}: Write a function to apply the softmax operation on a tensor. Your function should take two parameters: a tensor and a dimension $i$, and apply softmax to the $i$-th dimension of the input tensor. The output tensor should have the same shape as the input tensor, but its $i$-th dimension will now have a normalized probability distribution. Use the trick of subtracting the maximum value in the $i$-th dimension from all elements of the $i$-th dimension to avoid numerical stability issues.

To test your implementation, complete \texttt{[adapters.run\_softmax]} and make sure it passes \texttt{uv run pytest -k test\_softmax\_matches\_pytorch}.

\begin{lstlisting}
# uv run pytest -k test_softmax_matches_pytorch
def softmax(x:torch.Tensor, dim:int) -> torch.Tensor:
    # [..., d_model] -> [..., d_model]
    x_exp = torch.exp(x - x.max(dim=dim, keepdim=True).values)
    return x_exp / x_exp.sum(dim=dim,keepdim=True)
\end{lstlisting}

\problem{scaled\_dot\_product\_attention}{Implement scaled dot-product attention (5 points)}

\textbf{Deliverable}: Implement the scaled dot-product attention function. Your implementation should handle keys and queries of shape \lstinline{(batch_size, ..., seq_len, d_k)} and values of shape \lstinline{(batch_size, ..., seq_len, d_v)}, where \lstinline{...} represents any number of other batch-like dimensions (if provided). The implementation should return an output with the shape \lstinline{(batch_size, ..., d_v)}. See section 3.3 for a discussion on batch-like dimensions.

Your implementation should also support an optional user-provided boolean mask of shape \lstinline{(seq_len, seq_len)}. The attention probabilities of positions with a mask value of \lstinline{True} should collectively sum to 1, and the attention probabilities of positions with a mask value of \lstinline{False} should be zero.

To test your implementation against our provided tests, you will need to implement the test adapter at \texttt{[adapters.run\_scaled\_dot\_product\_attention]}.

\texttt{uv run pytest -k test\_scaled\_dot\_product\_attention} tests your implementation on third-order input tensors, while \texttt{uv run pytest -k test\_4d\_scaled\_dot\_product\_attention} tests your implementation on fourth-order input tensors.

\begin{lstlisting}
# uv run pytest -k test_scaled_dot_product_attention
# uv run pytest -k test_4d_scaled_dot_product_attention
from .nn_utils import softmax
def scaled_dot_product_attention(
    Q: torch.Tensor,
    K: torch.Tensor,
    V: torch.Tensor,
    mask: torch.Tensor = None,
) -> torch.Tensor:
    D = Q.size(-1)
    scores = torch.matmul(Q, K.transpose(-2, -1)) / math.sqrt(D)
    if mask is not None:
        scores = scores.masked_fill(mask == 0, float('-inf'))
    attn_weights = softmax(scores, dim=-1)
    output = torch.matmul(attn_weights, V)
    return output
\end{lstlisting}

\problem{multihead\_self\_attention}{Implement causal multi-head self-attention (5 points)}

\textbf{Deliverable}: Implement causal multi-head self-attention as a \lstinline{torch.nn.Module}. Your implementation should accept (at least) the following parameters:

\begin{itemize}
    \item \lstinline{d_model: int} - Dimensionality of the Transformer block inputs.
    \item \lstinline{num_heads: int} - Number of heads to use in multi-head self-attention.
\end{itemize}

Following \citet{vaswani2017attention}, set $d_k = d_v = d_{\text{model}}/h$. To test your implementation against our provided tests, implement the test adapter at \texttt{[adapters.run\_multihead\_self\_attention]}. 

Then, run \texttt{uv run pytest -k test\_multihead\_self\_attention} to test your implementation.

\begin{lstlisting}
# uv run pytest -k test_multihead_self_attention
# pass tests/test_model.py::test_multihead_self_attention
from einops import rearrange
class MultiheadSelfAttention(nn.Module):
    """ Multi-head self-attention layer """
    d_model: int
    num_heads: int
    
    def __init__(self, d_model:int, num_heads:int) -> None:
        super().__init__()
        assert d_model % num_heads == 0, "d_model must be divisible by num_heads"
        self.d_model = d_model
        self.num_heads = num_heads
        self.head_dim = d_model // num_heads
        self.fc_qkv = Linear(d_model, 3*d_model)
        self.fc_out = Linear(d_model, d_model)
    
    def forward(self, x:torch.Tensor) -> torch.Tensor:
        # [batch, seq_len, d_model] -> [batch, seq_len, d_model]
        seq_len = x.size(1)
        qkv = self.fc_qkv(x)
        qkv = rearrange(qkv, 'B T (nH Hs) -> B nH T Hs', Hs=self.head_dim)
        xq, xk, xv = torch.chunk(qkv, 3, dim=1)
        mask = torch.ones((seq_len, seq_len), device=x.device).tril()
        mask = rearrange(mask, 'T1 T2 -> 1 1 T1 T2')
        xo = scaled_dot_product_attention(xq, xk, xv, mask)
        xo = rearrange(xo, 'B nH T Hs -> B T (nH Hs)')
        return self.fc_out(xo)

# uv run pytest -k test_multihead_self_attention
# pass tests/test_model.py::test_multihead_self_attention_with_rope
class MultiheadRoPESelfAttention(nn.Module):
    """ Multi-head self-attention layer with RoPE"""
    d_model: int
    num_heads: int
    
    def __init__(
        self, 
        d_model:int, 
        num_heads:int,
        max_seq_len:int,
        theta:float,
    ) -> None:
        super().__init__()
        assert d_model % num_heads == 0, "d_model must be divisible by num_heads"
        self.d_model = d_model
        self.num_heads = num_heads
        self.head_dim = d_model // num_heads
        self.fc_qkv = Linear(d_model, 3*d_model)
        self.fc_out = Linear(d_model, d_model)
        self.rope = RotaryPositionalEmbedding(theta, self.head_dim, max_seq_len)
    
    def forward(self, x:torch.Tensor, token_positions: torch.Tensor = None) -> torch.Tensor:
        # [batch, seq_len, d_model] -> [batch, seq_len, d_model]
        seq_len = x.size(1)
        qkv = self.fc_qkv(x)
        qkv = rearrange(qkv, 'B T (nH Hs) -> B nH T Hs', Hs=self.head_dim)
        xq, xk, xv = torch.chunk(qkv, 3, dim=1)
        xq = self.rope(xq, token_positions)
        xk = self.rope(xk, token_positions)
        mask = torch.ones((seq_len, seq_len), device=x.device).tril()
        mask = rearrange(mask, 'T1 T2 -> 1 1 T1 T2')
        xo = scaled_dot_product_attention(xq, xk, xv, mask)
        xo = rearrange(xo, 'B nH T Hs -> B T (nH Hs)')
        return self.fc_out(xo)
\end{lstlisting}

\problem{transformer\_block}{Implement the Transformer block (3 points)}

Implement the pre-norm Transformer block as described in §3.5 and illustrated in Figure 2. Your Transformer block should accept (at least) the following parameters:

\begin{itemize}
    \item \lstinline{d_model: int} - Dimensionality of the Transformer block inputs.
    \item \lstinline{num_heads: int} - Number of heads to use in multi-head self-attention.
    \item \lstinline{d_ff: int} - Dimensionality of the position-wise feed-forward inner layer.
\end{itemize}

To test your implementation, implement the adapter \lstinline{[adapters.run_transformer_block]}. Then run \lstinline{uv run pytest -k test_transformer_block} to test your implementation.

\textbf{Deliverable}: Transformer block code that passes the provided tests.

\begin{answer}
\textbf{Note}: I reimplemented a separate attention module (\lstinline{TransformerAttention}) specifically designed to pass the later tests by having the correct parameter names and structure that can directly load state dictionaries (\lstinline{load_state_dict}) from the provided test weights. This module uses separate projection layers (\lstinline{q_proj}, \lstinline{k_proj}, \lstinline{v_proj}, \lstinline{output_proj}) instead of the combined \lstinline{fc_qkv} approach used in \lstinline{MultiheadSelfAttention}.

The Transformer block implementation includes several optional parameters to allow for flexibility in experimentation (for ablation studies later):
\begin{itemize}
    \item \lstinline{ffn_type: str = 'swiglu'} - Type of feed-forward network to use. Options are 'swiglu' for SwiGLU and 'silu' for SiLU-based FFN.
    \item \lstinline{use_post_norm: bool = False} - If set to True, applies layer normalization after the attention and feed-forward sub-layers (post-norm). If False, applies layer normalization before these sub-layers (pre-norm).
    \item \lstinline{remove_rmsnorm: bool = False} - If set to True, removes RMSNorm layers and replaces them with identity mappings.
    \item \lstinline{remove_rope: bool = False} - If set to True, removes RoPE from the attention mechanism.
\end{itemize}
\end{answer}

\begin{lstlisting}
from functools import lru_cache

@lru_cache(1)
def get_rope(theta: float, d_k: int, max_seq_len: int) -> RotaryPositionalEmbedding:
    return RotaryPositionalEmbedding(theta, d_k, max_seq_len)

class TransformerAttention(nn.Module):
    """ Transformer Attention with RoPE for TransformerBlock """
    d_model: int
    num_heads: int
    
    def __init__(
        self, 
        d_model:int, 
        num_heads:int,
        max_seq_len:int,
        theta:float,
    ) -> None:
        super().__init__()
        assert d_model % num_heads == 0, "d_model must be divisible by num_heads"
        self.d_model = d_model
        self.num_heads = num_heads
        self.head_dim = d_model // num_heads
        self.q_proj = Linear(d_model, d_model)
        self.k_proj = Linear(d_model, d_model)
        self.v_proj = Linear(d_model, d_model)
        self.output_proj = Linear(d_model, d_model)
        self.rope = get_rope(theta, self.head_dim, max_seq_len)
    
    def forward(self, x:torch.Tensor, token_positions: torch.Tensor = None) -> torch.Tensor:
        # [batch, seq_len, d_model] -> [batch, seq_len, d_model]
        seq_len = x.size(1)
        q = self.q_proj(x)
        k = self.k_proj(x)
        v = self.v_proj(x)
        xq = rearrange(q, 'B T (nH Hs) -> B nH T Hs', Hs=self.head_dim)
        xk = rearrange(k, 'B T (nH Hs) -> B nH T Hs', Hs=self.head_dim)
        xv = rearrange(v, 'B T (nH Hs) -> B nH T Hs', Hs=self.head_dim)
        if self.rope is not None:
            xq = self.rope(xq, token_positions)
            xk = self.rope(xk, token_positions)
        mask = torch.ones((seq_len, seq_len), device=x.device).tril()
        mask = rearrange(mask, 'T1 T2 -> 1 1 T1 T2')
        xo = scaled_dot_product_attention(xq, xk, xv, mask)
        xo = rearrange(xo, 'B nH T Hs -> B T (nH Hs)')
        return self.output_proj(xo)


# uv run pytest -k test_transformer_block
class TransformerBlock(nn.Module):
    """ Transformer Block """
    def __init__(
        self,
        d_model:int,
        num_heads:int,
        d_ff:int,
        max_seq_len:int,
        theta:float,
        ffn_type:str = 'swiglu',
        use_post_norm:bool = False,
        remove_rmsnorm:bool = False,
        remove_rope:bool = False,
    ) -> None:
        super().__init__()
        self.attn = TransformerAttention(
            d_model, num_heads, max_seq_len, theta
        )
        if remove_rope:
            self.attn.rope = None

        if ffn_type == 'swiglu':
            self.ffn = SwiGLU(d_model, d_ff)
        elif ffn_type == 'silu':
            self.ffn = SiLUFFN(d_model, d_ff)
        else:
            raise ValueError(f"Unknown ffn_type: {ffn_type}")

        self.use_post_norm = use_post_norm
        if remove_rmsnorm:
            self.ln1 = nn.Identity()
            self.ln2 = nn.Identity()
        else:
            self.ln1 = RMSNorm(d_model)
            self.ln2 = RMSNorm(d_model)
        
    def forward(self, x:torch.Tensor) -> torch.Tensor:
        # [batch, seq_len, d_model] -> [batch, seq_len, d_model]
        if self.use_post_norm:
            x = self.ln1(x + self.attn(x))
            x = self.ln2(x + self.ffn(x))
        else:
            x = x + self.attn(self.ln1(x))
            x = x + self.ffn(self.ln2(x))
        return x
\end{lstlisting}

\problem{transformer\_lm}{Implementing the Transformer LM (3 points)}

Time to put it all together! Implement the Transformer language model as described in §3.1 and illustrated in Figure 1. At minimum, your implementation should accept all the aforementioned construction parameters for the Transformer block, as well as these additional parameters:

\begin{itemize}
    \item \lstinline{vocab_size: int} - The size of the vocabulary, necessary for determining the dimensionality of the token embedding matrix.
    \item \lstinline{context_length: int} - The maximum context length, necessary for determining the dimensionality of the position embedding matrix.
    \item \lstinline{num_layers: int} - The number of Transformer blocks to use.
\end{itemize}

To test your implementation against our provided tests, you will first need to implement the test adapter at \lstinline{[adapters.run_transformer_lm]}. Then, run \lstinline{uv run pytest -k test_transformer_lm} to test your implementation.

\textbf{Deliverable}: A Transformer LM module that passes the above tests.

\begin{note}
    We initialize the weights using the initialization method specified in the \lstinline{cs336_spring2025_assignment1_basics.pdf}.
    This approach ensures compliance with the given specifications for weight initialization.
\end{note}

\begin{lstlisting}
def init_weights(m:nn.Module):
    if isinstance(m, Linear):
        std = math.sqrt(2.0 / (m.in_features + m.out_features))
        nn.init.trunc_normal_(m.weight, mean=0.0, std=std, a=-3*std, b=3*std)
        if m.bias is not None:
            nn.init.zeros_(m.bias)
    elif isinstance(m, Embedding):
        nn.init.trunc_normal_(m.weight, mean=0.0, std=1.0, a=-3.0, b=3.0)
    elif isinstance(m, RMSNorm):
        nn.init.ones_(m.weight)

# uv run pytest -k test_transformer_lm
class TransformerLM(nn.Module):
    """ Transformer Language Model """
    def __init__(
        self,
        vocab_size:int,
        context_length:int,
        d_model:int,
        num_layers:int,
        num_heads:int,
        d_ff:int,
        rope_theta:float,
        ffn_type:str = 'swiglu',
        use_post_norm:bool = False,
        remove_rmsnorm:bool = False,
        remove_rope:bool = False,
    ) -> None:
        super().__init__()
        self.token_embeddings = Embedding(vocab_size, d_model)
        self.layers = nn.ModuleList([
            TransformerBlock(
                d_model, num_heads, d_ff, context_length, rope_theta,
                ffn_type=ffn_type,
                use_post_norm=use_post_norm,
                remove_rmsnorm=remove_rmsnorm,
                remove_rope=remove_rope,
            )
            for _ in range(num_layers)
        ])
        if remove_rmsnorm:
            self.ln_final = nn.Identity()
        else:
            self.ln_final = RMSNorm(d_model)
        self.lm_head = Linear(d_model, vocab_size)
        self.max_seq_len = context_length
        self.apply(init_weights)
        
    def forward(self, token_ids:torch.Tensor) -> torch.Tensor:
        # [batch, seq_len] -> [batch, seq_len, vocab_size]
        seq_len = token_ids.size(1)
        assert seq_len <= self.max_seq_len, "Sequence length exceeds model capacity"
        x = self.token_embeddings(token_ids)
        for layer in self.layers:
            x = layer(x)
        x = self.ln_final(x)
        logits = self.lm_head(x)
        return logits
\end{lstlisting}

\problem{transformer\_accounting}{Transformer LM resource accounting (5 points)}

\begin{enumerate}[label=(\alph*)]
    \item Consider GPT-2 XL, which has the following configuration:
    \begin{itemize}
        \item \lstinline{vocab_size: 50,257}
        \item \lstinline{context_length: 1,024}
        \item \lstinline{num_layers: 48}
        \item \lstinline{d_model: 1,600}
        \item \lstinline{num_heads: 25}
        \item \lstinline{d_ff: 6,400}
    \end{itemize}
    
    Suppose we constructed our model using this configuration. How many trainable parameters would our model have? Assuming each parameter is represented using single-precision floating point, how much memory is required to just load this model?
    
    \textbf{Deliverable}: A one-to-two sentence response.
    
    \begin{answer}
    Our GPT-2 XL model would have approximately 1.98 billion trainable parameters 
    
    \begin{equation*}
    \begin{aligned}
        \text{Total Parameters} &= \underbrace{50,257 \times 1,600}_{\text{embeddings}} + 48 \times (\underbrace{4 \times 1,600^2}_{\text{attention}} + \underbrace{3 \times 1,600 \times 6,400}_{\text{SwiGLU}}) + \underbrace{1,600 \times 50,257}_{\text{output head}}\\
        &= 2,126,902,400
    \end{aligned}
    \end{equation*}

    Assuming single-precision floating point (32 bits = 4 bytes per parameter), the model would require approximately 7.92 GB of memory to load.
    \end{answer}
    
    \item Identify the matrix multiplies required to complete a forward pass of our GPT-2 XL-shaped model. How many FLOPs do these matrix multiplies require in total? Assume that our input sequence has \lstinline{context_length} tokens.
    
    \textbf{Deliverable}: A list of matrix multiplies (with descriptions), and the total number of FLOPs required.
    
    \begin{answer}
    Per layer matrix multiplies are listed in the following table \ref{tab:gpt2xl_flops}, where $T$ = sequence length, $d_{\text{model}}$ = model dimension, $d_{\text{ff}}$ = feed-forward dimension, $d_k$ = head dimension, $h$ = number of heads, $V$ = vocabulary size.
    Total per layer: $90,596,966,400 \approx 90.6\text{B FLOPs}$, and for 48 layers: $4,348,654,387,200 \approx 4.35$ trillion FLOPs, and for final projection: $2 \times 1,024 \times 1,600 \times 50,257 = 165,566,873,600 \approx 165.57\text{B FLOPs}$, so the total is $4,514,221,260,800 \approx 4.51$ trillion FLOPs.
    \end{answer}

    \begin{table}[h]
    \centering
    \caption{Matrix multiplications and FLOP calculations for GPT-2 XL forward pass}
    \label{tab:gpt2xl_flops}
    \scalebox{1}{
    \begin{tabular}{|l|l|l|l|}
    \hline
    \textbf{Operation} & \textbf{Mathematical Formula} & \textbf{FLOP Formula} & \textbf{GPT-2 XL Calculation} \\
    \hline
    Q projection & $Q = W_Q \cdot X$ & $2 \times T \times d_{\text{model}} \times d_{\text{model}}$ & $2 \times 1024 \times 1600 \times 1600 = 5.24$B \\
    \hline
    K projection & $K = W_K \cdot X$ & $2 \times T \times d_{\text{model}} \times d_{\text{model}}$ & $2 \times 1024 \times 1600 \times 1600 = 5.24$B \\
    \hline
    V projection & $V = W_V \cdot X$ & $2 \times T \times d_{\text{model}} \times d_{\text{model}}$ & $2 \times 1024 \times 1600 \times 1600 = 5.24$B \\
    \hline
    Attention scores & $S = Q \cdot K^T / \sqrt{d_k}$ & $2 \times h \times T \times d_k \times T$ & $2 \times 25 \times 1024 \times 64 \times 1024 = 3.36$B \\
    \hline
    Attention output & $A = S \cdot V$ & $2 \times h \times T \times T \times d_k$ & $2 \times 25 \times 1024 \times 1024 \times 64 = 3.36$B \\
    \hline
    Output projection & $O = W_O \cdot A$ & $2 \times T \times d_{\text{model}} \times d_{\text{model}}$ & $2 \times 1024 \times 1600 \times 1600 = 5.24$B \\
    \hline
    SwiGLU $W_1$ & $G_1 = W_1 \cdot X$ & $2 \times T \times d_{\text{model}} \times d_{\text{ff}}$ & $2 \times 1024 \times 1600 \times 6400 = 20.97$B \\
    \hline
    SwiGLU $W_2$ & $Y = W_2 \cdot G_{\text{activated}}$ & $2 \times T \times d_{\text{ff}} \times d_{\text{model}}$ & $2 \times 1024 \times 6400 \times 1600 = 20.97$B \\
    \hline
    SwiGLU $W_3$ & $G_3 = W_3 \cdot X$ & $2 \times T \times d_{\text{model}} \times d_{\text{ff}}$ & $2 \times 1024 \times 1600 \times 6400 = 20.97$B \\
    \hline
    \multicolumn{3}{|r|}{\textbf{Total per layer:}} & \textbf{90.6B FLOPs} \\
    \hline
    \multicolumn{3}{|r|}{\textbf{48 layers total:}} & \textbf{4.35T FLOPs} \\
    \hline
    Final projection & $\text{logits} = W_{\text{lm}} \cdot H$ & $2 \times T \times d_{\text{model}} \times V$ & $2 \times 1024 \times 1600 \times 50257 = 165.57$B \\
    \hline
    \multicolumn{3}{|r|}{\textbf{Grand total:}} & \textbf{4.51T FLOPs} \\
    \hline
    \end{tabular}
    }
    \end{table}
    
    \item Based on your analysis above, which parts of the model require the most FLOPs?
    
    \textbf{Deliverable}: A one-to-two sentence response.
    
    \begin{answer}
    From the table \ref{tab:gpt2xl_flops} above, we can just use one formula to calculate the total FLOPs:
    \begin{equation*}
        \begin{aligned}
            \text{Total FLOPs} &= N_{\text{layer}} (
                \underbrace{4 \times 2 \times T d_{\text{model}}^2}_{\text{projection}} + 
                \underbrace{2 \times 2 \times h d_{k} \times T^2}_{\text{attention}} + 
                \underbrace{3 \times 2 \times T d_{\text{model}} d_{\text{ff}}}_{\text{feed-forward}}) + \underbrace{2 \times T d_{\text{model}} \times V}_{\text{output head}} \\
            &= 2 T d_{\text{model}} \left(
                {\color{magenta}N_{\text{layer}}  \left(
                    4 d_{\text{model}} + 2 T + 3 d_{\text{ff}}
                \right) + V}
            \right)
        \end{aligned}
    \end{equation*}

    The SwiGLU feed-forward networks consume the most FLOPs, accounting for approximately 67.0\% of the total, while attention mechanisms account for about 29.4\% of the computation, and embedding operations account for the remaining 3.6\%.
    \end{answer}
    
    \item Repeat your analysis with GPT-2 small (12 layers, 768 \lstinline{d_model}, 12 heads), GPT-2 medium (24 layers, 1024 \lstinline{d_model}, 16 heads), and GPT-2 large (36 layers, 1280 \lstinline{d_model}, 20 heads). As the model size increases, which parts of the Transformer LM take up proportionally more or less of the total FLOPs?
    
    \textbf{Deliverable}: For each model, provide a breakdown of model components and its associated FLOPs (as a proportion of the total FLOPs required for a forward pass). In addition, provide a one-to-two sentence description of how varying the model size changes the proportional FLOPs of each component.
    
    \begin{answer}
    GPT-2 model configurations and FLOP breakdown are shown in Table~\ref{tab:gpt2-comparison}. 
    As model size increases, the feed-forward networks consume a larger proportion of FLOPs while embedding operations become negligible, with attention maintaining roughly constant proportional cost across all model sizes.
    \end{answer}
    
    \begin{table}[h]
    \centering
    \caption{GPT-2 model configurations and computational requirements comparison}
    \label{tab:gpt2-comparison}
    \scalebox{0.85}{
    \begin{tabular}{|l|l|l|}
    \hline
    \textbf{Our Model} & \textbf{Configuration} & \textbf{FLOP Breakdown (per forward pass)} \\
    \hline
    GPT-2 Small & 
    \begin{tabular}{@{}l@{}}
    $N_{\text{layer}} = 12$ \\
    $d_{\text{model}} = 768$ \\
    $h = 12$ \\
    $d_{\text{ff}} = 3072$
    \end{tabular} & 
    \begin{tabular}{@{}l@{}}
    Attention: $\sim$27.6\% (0.10T FLOPs) \\
    FFN: $\sim$49.8\% (0.17T FLOPs) \\
    Embeddings: $\sim$22.6\% (0.08T FLOPs) \\
    \textbf{Total: 0.35T FLOPs}
    \end{tabular} \\
    \hline
    GPT-2 Medium & 
    \begin{tabular}{@{}l@{}}
    $N_{\text{layer}} = 24$ \\
    $d_{\text{model}} = 1024$ \\
    $h = 16$ \\
    $d_{\text{ff}} = 4096$
    \end{tabular} & 
    \begin{tabular}{@{}l@{}}
    Attention: $\sim$29.9\% (0.31T FLOPs) \\
    FFN: $\sim$59.9\% (0.62T FLOPs) \\
    Embeddings: $\sim$10.2\% (0.11T FLOPs) \\
    \textbf{Total: 1.03T FLOPs}
    \end{tabular} \\
    \hline
    GPT-2 Large & 
    \begin{tabular}{@{}l@{}}
    $N_{\text{layer}} = 36$ \\
    $d_{\text{model}} = 1280$ \\
    $h = 20$ \\
    $d_{\text{ff}} = 5120$
    \end{tabular} & 
    \begin{tabular}{@{}l@{}}
    Attention: $\sim$30.0\% (0.68T FLOPs) \\
    FFN: $\sim$64.2\% (1.45T FLOPs) \\
    Embeddings: $\sim$5.8\% (0.13T FLOPs) \\
    \textbf{Total: 2.26T FLOPs}
    \end{tabular} \\
    \hline
    GPT-2 XL & 
    \begin{tabular}{@{}l@{}}
    $N_{\text{layer}} = 48$ \\
    $d_{\text{model}} = 1600$ \\
    $h = 25$ \\
    $d_{\text{ff}} = 6400$
    \end{tabular} & 
    \begin{tabular}{@{}l@{}}
    Attention: $\sim$29.4\% (1.33T FLOPs) \\
    FFN: $\sim$66.9\% (3.02T FLOPs) \\
    Embeddings: $\sim$3.6\% (0.16T FLOPs) \\
    \textbf{Total: 4.51T FLOPs}
    \end{tabular} \\
    \hline
    \end{tabular}
    }
    \end{table}
    
    \textit{Note:} All calculations assume sequence length $T = 1024$. $N_{\text{layer}}$ = number of transformer layers, $d_{\text{model}}$ = model dimension, $h$ = number of attention heads, $d_{\text{ff}} = 4 \times d_{\text{model}}$ following \citet{radford2019language}.

    \item Take GPT-2 XL and increase the context length to 16,384. How does the total FLOPs for one forward pass change? How do the relative contribution of FLOPs of the model components change?
    
    \textbf{Deliverable}: A one-to-two sentence response.
    
    \begin{answer}
    Increasing context length from 1,024 to 16,384 ($16\times$ increase) results in total FLOPs increasing by approximately $33\times$ to $\sim149.5$ trillion FLOPs, with attention computation scaling quadratically ($256\times$ increase) while feed-forward computation scales linearly ($16\times$ increase). This shifts the computational balance such that attention now consumes approximately 65.9\% of total FLOPs instead of 29.4\%, making attention the dominant computational bottleneck at very long sequences.
    \end{answer}
\end{enumerate}